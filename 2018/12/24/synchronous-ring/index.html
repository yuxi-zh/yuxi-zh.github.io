<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="之前已经证明了在异步环上的选主算法消息复杂度为$\Omega(n \log n)$。异步环上基本假设是消息可能会被延迟任意长度的时间，而在同步环基本假设是消息延迟是固定的。后面会看到，在同步环的假设下，一轮执行中有用的信息不但可以根据接收消息获知，而且可以根据未接收到消息获知。这一特性是导致同步环上选主算法时间复杂度上下界不同于异步环的根本原因。 消息复杂度上界$O(n)$非一致算法非一致算法选择">
<meta name="keywords" content="distributed computing">
<meta property="og:type" content="article">
<meta property="og:title" content="同步环上的选主问题">
<meta property="og:url" content="http://yuxi-zh.github.io/2018/12/24/synchronous-ring/index.html">
<meta property="og:site_name" content="Yuxiang Zhang&#39;s Blog">
<meta property="og:description" content="之前已经证明了在异步环上的选主算法消息复杂度为$\Omega(n \log n)$。异步环上基本假设是消息可能会被延迟任意长度的时间，而在同步环基本假设是消息延迟是固定的。后面会看到，在同步环的假设下，一轮执行中有用的信息不但可以根据接收消息获知，而且可以根据未接收到消息获知。这一特性是导致同步环上选主算法时间复杂度上下界不同于异步环的根本原因。 消息复杂度上界$O(n)$非一致算法非一致算法选择">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2018-12-27T14:00:01.332Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="同步环上的选主问题">
<meta name="twitter:description" content="之前已经证明了在异步环上的选主算法消息复杂度为$\Omega(n \log n)$。异步环上基本假设是消息可能会被延迟任意长度的时间，而在同步环基本假设是消息延迟是固定的。后面会看到，在同步环的假设下，一轮执行中有用的信息不但可以根据接收消息获知，而且可以根据未接收到消息获知。这一特性是导致同步环上选主算法时间复杂度上下界不同于异步环的根本原因。 消息复杂度上界$O(n)$非一致算法非一致算法选择">






  <link rel="canonical" href="http://yuxi-zh.github.io/2018/12/24/synchronous-ring/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>同步环上的选主问题 | Yuxiang Zhang's Blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yuxiang Zhang's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yuxi-zh.github.io/2018/12/24/synchronous-ring/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yuxiang Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuxiang Zhang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">同步环上的选主问题

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-12-24 20:27:23" itemprop="dateCreated datePublished" datetime="2018-12-24T20:27:23+08:00">2018-12-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-27 22:00:01" itemprop="dateModified" datetime="2018-12-27T22:00:01+08:00">2018-12-27</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>之前已经证明了在异步环上的选主算法消息复杂度为$\Omega(n \log n)$。异步环上基本假设是消息可能会被延迟任意长度的时间，而在同步环基本假设是消息延迟是固定的。后面会看到，在同步环的假设下，一轮执行中有用的信息不但可以根据接收消息获知，而且可以根据未接收到消息获知。这一特性是导致同步环上选主算法时间复杂度上下界不同于异步环的根本原因。</p>
<h2 id="消息复杂度上界-O-n"><a href="#消息复杂度上界-O-n" class="headerlink" title="消息复杂度上界$O(n)$"></a>消息复杂度上界$O(n)$</h2><h3 id="非一致算法"><a href="#非一致算法" class="headerlink" title="非一致算法"></a>非一致算法</h3><p>非一致算法选择拥有最小标识符的处理器作为Leader。算法按阶段工作，每个阶段有n轮。在第$i$阶段，如果有一个处理器的标识符为$i$，那么该处理器被选为Leader，并按找环方向传播标识符$i$并结束执行。如果处理器接在阶段$i$接收到标志符$i$，那么它转发消息并结束执行。</p>
<p>标识符互不相同，一定是拥有最小标志符的处理器被选为Leader。该算法导致n条消息发送，且这n条消息均在Leader被发现的阶段被发送。算法执行的轮数取决于环中最小标识符的大小。如果最小标志符为$m$（从0开始计数），那么共需要$m\cdot(m+1)$轮算法结束。</p>
<font color="green">为什么标识符为$i$的处理器必须要在第$i$阶段发送消息？因为各处理器互不知道彼此的标识符。</font>

<h3 id="一致算法"><a href="#一致算法" class="headerlink" title="一致算法"></a>一致算法</h3><p>非一致算法必须知道环的大小且要求所有处理器同步开始，一致算法则可以避免这些限制。</p>
<ul>
<li>处于睡眠状态的处理器<code>i</code>自唤醒<ul>
<li>进入选举状态，发送<code>msg&lt;i&gt;</code></li>
</ul>
</li>
<li>处于睡眠状态的处理器接收<code>msg&lt;i&gt;</code><ul>
<li>进入转发状态，立即转发消息</li>
</ul>
</li>
<li>处于选举状态的处理器<code>i</code>接收到消息<code>msg&lt;j&gt;</code><ul>
<li>如果<code>i</code>等于<code>j</code>，该处理器被选为Leader</li>
<li>如果<code>j</code>小于该处理器发送过的最小标志符，延迟<code>2^j-1</code>轮后转发消息</li>
</ul>
</li>
<li>处于转发状态的消息处理器接收到消息<code>msg&lt;i&gt;</code><ul>
<li>如果<code>i</code>小于该处理器发送过的最小标识符，延迟<code>2^i-1</code>轮后转发消息</li>
</ul>
</li>
</ul>
<h4 id="消息复杂度分析"><a href="#消息复杂度分析" class="headerlink" title="消息复杂度分析"></a>消息复杂度分析</h4><p>消息<code>msg&lt;i&gt;</code>的生命周期被分为两个阶段：第一阶段为未到达选举状态处理器之前，传播速率为每轮传播一条边；第二阶段为到达选举状态处理器之后，传播速率为每$2^i$轮传播一条边。<font color="green">注意：一个消息在到达第一个唤醒后的处理器后，之后达到的每个处理器都是唤醒的。</font></p>
<p><strong>引理0：只有选举状态中标识符最小的处理器可以收到自己发送消息，该处理器作为最终的Leader。</strong></p>
<p>从存在性和唯一性两个方面进行证明。该引理只在证明算法的正确性。</p>
<p>下面证明该算法的消息复杂度，为此把消息分为三类：第一类为处于第一阶段的消息；第二类为在Leader消息进入第二阶段前发送的，当前处于第二阶段的消息；第三类为在Leader消息进入第二阶段后发送的，当前处于第二阶段的消息。</p>
<p><strong>引理1：第一类消息总数不超过$n$</strong></p>
<p>下面通过反证法证明每个处理器最多转发一个第一阶段消息。假设某个处理器$p_i$转发了两条第一阶段消息，两条消息分别是来自$p_j$的<code>msg&lt;j&gt;</code>和来自$p_k$的<code>msg&lt;k&gt;</code>。不失一般性的，可以假设顺时针方向上$p_j$距离$p_i$比$p_k$距离$p_i$更近，那么<code>msg&lt;k&gt;</code>在到达$p_i$前一定要经过$p_j$。如果<code>msg&lt;k&gt;</code>在$p_j$唤醒后到达$p_j$，那么<code>msg&lt;k&gt;</code>会进入第二阶段；否则$p_j$会退出选举，不会发送<code>msg&lt;j&gt;</code>。两种情况都不会出现$p_i$转发两条第一阶段消息的可能，导出矛盾。</p>
<p>在下面的表述中，let $r$ be <strong>the first round</strong> in which some processor starts executing thee algorithm and let $p_i$ be one of these processors。</p>
<p><strong>引理2：如果$p_j$与$p_i$的顺时针距离为$k$，那么$p_j$不迟于$r+k$轮收到一个第一阶段消息</strong></p>
<ul>
<li>归纳基础：$k=1$时命题显然成立。</li>
<li>归纳假设：距离$p_i$顺时针距离为$k-1$的处理器$p_{j-1}$不会迟于$r+k-1$轮收到一个第一阶段消息</li>
<li>归纳推理：如果$p_{j-1}$在收到第一个第一阶段消息时已经唤醒（参与选举），那么意味着$p_{j-1}$之前已经发送第一阶段消息给$p_j$，否则（不参与选举）会将收到的消息直接转发给$p_j$，所以$p_j$不会迟于$r+k$轮收到一个第一阶段消息。</li>
</ul>
<p><strong>引理3：第二类消息总数不超过$n$</strong></p>
<p>由引理2可知，不迟于$r+n$轮，每条边上都发送一条第一阶段消息，也就意味着在$r+n$轮后不再有第一阶段消息被发送。从而最终Leader的消息也不会迟于$r+n$轮进入第二阶段，所以第二类消息只可能在第$r$轮之后的$n$轮中发送。<code>msg&lt;i&gt;</code>在进入第二阶段后转发会被延迟$2^i-1$轮，当<code>msg&lt;i&gt;</code>属于第二类消息时，最多被转发$\frac{n}{2^i}$次，所以第二类消息总数上界为$\sum_{i=1}^{n-1}\frac{n}{2^i}\le n$。</p>
<p><strong>引理4：当消息<code>msg&lt;i&gt;</code>返回$p_i$后，不在有消息被转发</strong></p>
<p>一旦<code>msg&lt;i&gt;</code>返回$p_i$后，意味着$i$是参与选举的处理器中最小的标识符且所有的处理器都转发过该消息。</p>
<p><strong>引理5：第三类消息总数不超过$2n$</strong></p>
<p>令$p_i$为最终选出的Leader，$p_j$为另外一个参与选举的处理器，则必有$i &lt; j$。处于第二阶段的<code>msg&lt;i&gt;</code>转发会被延迟$2^i-1$轮，所以这个消息最多需要$n\cdot2^i$轮返回$p_i$。在这$n\cdot2^i$轮中<code>msg&lt;j&gt;</code>最多被转发$n\cdot 2^{i-j}$次，所以第三类消息总数上界为$\sum_{j=0}^{n-1}n\cdot 2^{i-j}=\sum_{k=0}^{n-1}\frac{n}{2^k}\le 2n$。</p>
<p><strong>定理：存在同步环上的选主算法消息复杂度最大为$4n$</strong></p>
<p>由引理1、引理3和引理5可知该定理成立。</p>
<h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>由引理5可知，当leader接收到自己的id时，计算终止。这发生在第一个启动算法的节点之后的$O(n\cdot2^i)$轮，其中i是leader的标识符。<font color="green">运行时间与环的大小以及标识符取值有关。</font></p>
<font color="green">为什么第二阶段消息要延迟$2^i-1$轮才转发？如何修改该算法来改善时间复杂性？</font>

<h2 id="有限制算法的下界-Omega-n-lg-n"><a href="#有限制算法的下界-Omega-n-lg-n" class="headerlink" title="有限制算法的下界$\Omega(n\lg n)$"></a>有限制算法的下界$\Omega(n\lg n)$</h2><p>上面一节给出的两种算法都有两不太好的性质：</p>
<ul>
<li>由标识符来决定一个消息要延迟多久</li>
<li>每个容许执行需要的轮数依赖处理器的标识符赋值</li>
</ul>
<p>相较于处理器数量，标识符可以非常大，那么这种情况下两种算法的时间复杂度都非常的糟糕。那么在这一节将会证明下面三个命题：</p>
<ul>
<li>对于任何消息高效的算法（消息复杂度$O(n)$），这两个性质是固有的</li>
<li>一个同步选主算法中，如果标识符只用于比较，那么消息复杂度有$\Omega(n\log n)$下界</li>
<li>一个同步选主算法中，如果限制轮数上界，轮数关于标识符独立，那么消息复杂度有$\Omega(n\log n)$下界</li>
</ul>
<h3 id="基于比较的算法"><a href="#基于比较的算法" class="headerlink" title="基于比较的算法"></a>基于比较的算法</h3><font color="red">为了得到下界，假设所有的处理器在同一轮开始执行算法</font>

<p>在同步模型中，一个算法的容许执行完全由初始配置决定。而系统的初始配置完全由环定义决定，即环上处理器的标志符分配。在指定具体算法后，记环$R$上容许执行为$exec(R)$。</p>
<p><strong>定义（匹配）</strong>，环$R_1$中的处理器$p_i$和环$R_2$中的处理器$p_j$匹配当且仅当两者距离各自环中最小标识符处理器顺时针距离相同。</p>
<p><strong>定义（序等价）</strong>，环$x_0,x_1,\dots,x_n-1$和$y_0,y_1,\dots,y_n$序等价当且仅当对任意的$i和j$，$x_i\lt x_j \Leftrightarrow y_i \lt y_j$。</p>
<font color="red">不太理解为什么k邻居是序相等的扩展。</font>

<p><strong>定义（第k轮行为相似）</strong>，处理器$p_i$在$\alpha_1$和处理器$p_j$在$\alpha_2$在第k轮行为相似当且仅当满足于下两点要求</p>
<ul>
<li>在第k轮，$\alpha_1$中$p_i$向左/右发送消息$\Leftrightarrow$$\alpha_2$中$p_j$向左/右发送消息</li>
<li>在第k轮，$\alpha_1$中$p_i$选举胜利结束算法$\Leftrightarrow$$\alpha_2$中$p_j$选举胜利结束算法</li>
</ul>
<p><strong>定义（行为相似）</strong>，处理器$p_i$在$\alpha_1$和处理器$p_j$在$\alpha_2$行为相似当且仅当两者在所有轮行为相似。</p>
<p><strong>定义（基于比较的算法）</strong>，一个算法是基于比较的，仅当对于任意序等价的环$R_1$和$R_2$，每对匹配的节点在$exec(R_1)$和$exec(R_2)$里的行为均相似。<font color="green">该定义说明，若一算法只与环上标识符之间的相对次序相关，而与具体id值无关，则该算法一定只是基于标识符的比较。</font></p>
<h3 id="基于比较算法的消息复杂度下界"><a href="#基于比较算法的消息复杂度下界" class="headerlink" title="基于比较算法的消息复杂度下界"></a>基于比较算法的消息复杂度下界</h3><font color="red">为了得到下界，假设基于比较算法A执行在高度对称的环上，即任意两个处理器都有序等价的邻居，这样在A下两者的行为相似。</font>

<font color="green">The nonexistence of a messaage in a certain round $r$ is useful to processor $p_i$ only if a message could have been received in this round in a different, but order-equivalent ring.</font> 这句话在描述对于一个处理器而言在某一轮中从“未收到任何消息”这一结果中获得有效信息的条件。<br><br><strong>定义（主动轮，active round)</strong>，A round $r$ is active in an execution on a ring $R$ if some processor sends a message in round $r$ of the execution. When $R$ is understood from context, we denote by $r_k$ the index of the $k$-th active round.<br><br><strong>引理：</strong> 设$R_1$和$R_2$是次序等价的两个环，设$p_i$和$p_j$分别是$R_1$和$R_2$上具有相同$k$-邻居的两个节点，那么在$exec(R_1)$的第1至第$r_k$轮里$p_i$所经历的转换序列和在$exec(R_2)$的第1至第$r_k$轮里$p_j$所经历的转换序列相同。<font color="green">证明思路：通过归纳法即可证明。</font>

<p><strong>引理：</strong> 设$R$是有空隙环（即环中每两个标识符之间均有$n$个未使用的标识符），$p_i$和$p_j$是$R$上具有序等价$k$-邻居的两个结点，则$p_i$和$p_j$在$exec(R)$的第1到第$r_k$轮里行为相似。</p>
<font color="green">构造$R’$满足下面条件，然后分别证明$p_i(R) \sim p_j(R’)$，$p_j(R) \sim p_j(R’)$，然后由等价关系的传递性证明$p_i(R) \sim p_j(R)$。</font>

<ul>
<li>$R’$中的$p_j$和$R$中$p_i$的有相同的$k$-邻居</li>
<li>$R’$中的标识符唯一</li>
<li>$R’$和$R$序等价，$R’$中的$p_j$匹配于$R$中的$p_j$</li>
</ul>
<p><strong>定理：</strong> 对于每个$n \ge 8$($n$是2的幂)，存在一个大小为$n$的环$S_n$，使得对每个基于比较的同步选主算法$A$，在$S_n$上$A$的容许执行里发送消息数目为$\Omega(n\lg n)$</p>
<font color="green">固定基于比较的同步选主算法$A$，证明分为两步：首先构造一个高度堆成的环$S_n$，然后计算$S_n$上消息总数。</font>

<ul>
<li><strong>$S_n$的构造</strong>，首先定义大小为$n$的环$R_n^{rev}$，然后将环上每个标识符$i$变换为$i\times (n+1)+n$的带空隙环$S_n$。该变换不改变序等价性。</li>
<li><strong>计算$S_n$上消息总数</strong>，首先求$S_n$中序等价的邻居集数目，然后求算法$A$中主动轮数目下界，然后求每个主动轮发送消息下界。</li>
</ul>
<p><strong>引理：</strong> 对所有$k\lt\frac{n}{8}$以及每个$S_n$的$k$邻居集，在$S_n$中与$N$序等价的$k$邻居集（包含$N$自身）的个数大于$\frac{n}{2(2k+1)}$。<font color="green">对$S_n$进行最小方幂划分，每个划分包含一个$k$邻居集，各划分的邻居集序等价。</font></p>
<p><strong>引理：</strong> 在$exec(S_n)$里，主动轮的数目至少为$\frac{n}{8}$。<font color="green">证明当主动轮数目$T$小于$f\frac{n}{8}$时，$S_n$的$T$邻居集不止一个。</font></p>
<p><strong>引理：</strong> 对于$\forall k \in [1, \frac{n}{8}]$，在$exec(S_n)$的第$k$个主动轮中，至少有$\frac{n}{2(2k+1)}$个消息发送。<font color="green">主动轮中至少一个节点发送一个消息，结合邻居集的序等价性和行为相似性进行证明</font></p>
<p>综合上述引理可以计算$S_n$上消息总数下界为$\sum_{k=1}^{\frac{n}{8}}\frac{n}{2(2k+1)}\gt \frac{n}{6}\ln \frac{n}{8} = \Omega(n\lg n)$。</p>
<h3 id="时间受限算法的消息复杂度-Omega-n-lg-n"><a href="#时间受限算法的消息复杂度-Omega-n-lg-n" class="headerlink" title="时间受限算法的消息复杂度$\Omega(n\lg n)$"></a>时间受限算法的消息复杂度$\Omega(n\lg n)$</h3><font color="green">将时间受限算法映射为基于比较算法，从而得到时间复杂度$\Omega(n\lg n)$。</font>简单起见下述讨论只针对环大小为2的方幂情况进行讨论。<br><br><strong>定义（$t$-比较）：</strong> 设$R_1$和$R_2$是任意两个大小为$n$的序等价的环，若每对匹配的结点在$exec(R_1)$和$exec(R_2)$的第1至$t$轮里有相似的行为，则同步算法$A$对于环大小为$n$的标识符集合$S$是基于$t$-比较的。<br><br><strong>定义（等价子集）：</strong> $Y$和$Z$称为等价子集，若对于每对序等价的环$R_1$和$R_2$(两者标识符分别来自于$Y$和$Z$)，每对匹配的结点在$exec(R_1)$和$exec(R_2)$的第1至$t$轮里有相似的行为。<br><br><strong>拉姆齐（Ramsey）定理的有限形式：</strong> 对于所有正整数$k$、$l$和$t$，存在一个正整数$f(k,l,t)$使得对每个大小至少为$f(k,l,t)$的集合$S$，对$S$所有的$k$元子集进行$t$着色，则存在$S$的某个$l$元子集中所有的$k$元子集具有相同的颜色。<br><br><strong>引理：</strong> 设$A$是一个运行时间为$r(n)$的运行时间首先的同步算法，对于每个$n$，存在一个大小为$n^2+2n$标识符集合$C_n$，使得$A$是$C_n$上的一个基于$r(n)$-比较算法，这里$n$是环的大小。<font color="green">将自然数集合根据等价子集关系划分为等价类（着色），根据Ramsey定理，对于自然数集合$N$（即$S$），存在势为$n^2+2n$（即$l$）的集合$C_n$所有$n$（即$k$）元子集都属于同一等价类</font>。<br><br><strong>定理：</strong> 对每个同步的时间有界的选主算法$A$，以及每个$n\gt 8$，$n$为2的方幂，存在一个大小为$n$的环$R$，使得$A$在$R$上的容许执行里发送$\Omega(n\lg n)$个消息。<font color="green">将$C_n$中元素排序后一一映射到$0,1,\dots,n^2+2n-1$，然后根据基于比较算法时间下界定理得证。</font>










      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/distributed-computing/" rel="tag"># distributed computing</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/24/software-pipelining/" rel="next" title="软件流水">
                <i class="fa fa-chevron-left"></i> 软件流水
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yuxiang Zhang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#消息复杂度上界-O-n"><span class="nav-number">1.</span> <span class="nav-text">消息复杂度上界$O(n)$</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#非一致算法"><span class="nav-number">1.1.</span> <span class="nav-text">非一致算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一致算法"><span class="nav-number">1.2.</span> <span class="nav-text">一致算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#消息复杂度分析"><span class="nav-number">1.2.1.</span> <span class="nav-text">消息复杂度分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间复杂度分析"><span class="nav-number">1.2.2.</span> <span class="nav-text">时间复杂度分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有限制算法的下界-Omega-n-lg-n"><span class="nav-number">2.</span> <span class="nav-text">有限制算法的下界$\Omega(n\lg n)$</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基于比较的算法"><span class="nav-number">2.1.</span> <span class="nav-text">基于比较的算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于比较算法的消息复杂度下界"><span class="nav-number">2.2.</span> <span class="nav-text">基于比较算法的消息复杂度下界</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时间受限算法的消息复杂度-Omega-n-lg-n"><span class="nav-number">2.3.</span> <span class="nav-text">时间受限算法的消息复杂度$\Omega(n\lg n)$</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuxiang Zhang</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  
  <script src="/js/src/scrollspy.js?v=6.6.0"></script>
<script src="/js/src/post-details.js?v=6.6.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  











  





  

  

  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<style>
.MathJax_Display {
    overflow: auto hidden;
}
</style><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

    
  


  
  

  

  

  

  

  

  

</body>
</html>
